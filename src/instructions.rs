use std::fmt;
use registers::{Reg8,Reg16,Indirect};

#[derive(Copy,Clone,Debug,Eq,PartialEq)]
pub enum Cond {
    Z, NZ, C, NC, Always
}
impl Cond {
    pub fn from(bits: u8) -> Self {
        match bits {
            0 => Cond::NZ,
            1 => Cond::Z,
            2 => Cond::NC,
            3 => Cond::C,
            _ => unreachable!("Invalid condition code")
        }
    }
}
impl fmt::Display for Cond {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Cond::Z => write!(f, " Z"),
            Cond::NZ => write!(f, " NZ"),
            Cond::C => write!(f, " C"),
            Cond::NC => write!(f, " NC"),
            Cond::Always => Ok(())
        }
    }
}

#[derive(Copy,Clone,Debug,Eq,PartialEq)]
pub enum Instr {
    Bad(u8),
    Nop,
    Stop,
    StoreSP(u16),
    JumpRelative(i8, Cond),
    LoadImm16(Reg16, u16),
    AddHL(Reg16),
    StoreA(Indirect),
    LoadA(Indirect),
    Inc16(Reg16),
    Dec16(Reg16),
    Inc8(Reg8),
    Dec8(Reg8),
    LoadImm8(Reg8, u8),
    RotateALeft,
    RotateALeftCarry,
    RotateARight,
    RotateARightCarry,
    DecimalAdjust,
    Complement,
    ComplementCarry,
    SetCarry,
    Halt,
    RegCopy(Reg8,Reg8),
    Add(Reg8),
    AddImm(u8),
    AddCarry(Reg8),
    AddCarryImm(u8),
    Sub(Reg8),
    SubImm(u8),
    SubCarry(Reg8),
    SubCarryImm(u8),
    And(Reg8),
    AndImm(u8),
    Xor(Reg8),
    XorImm(u8),
    Or(Reg8),
    OrImm(u8),
    Comp(Reg8),
    CompImm(u8),
    Ret(Cond),
    RetI,
    StoreIO(u8),
    LoadIO(u8),
    StackAdjust(i8),
    LoadLocalAddr(i8),
    Pop(Reg16),
    Push(Reg16),
    Jump(u16, Cond),
    JumpHL,
    LoadStackHL,
    StoreIOC,
    LoadIOC,
    StoreGlobal(u16),
    LoadGlobal(u16),
    DisableInterrupts,
    EnableInterrupts,
    Call(u16, Cond),
    Restart(u8),
    Bit(Reg8, u8),
    Reset(Reg8, u8),
    Set(Reg8, u8),
    RotateLeft(Reg8),
    RotateRight(Reg8),
    RotateLeftCarry(Reg8),
    RotateRightCarry(Reg8),
    ShiftLeft(Reg8),
    ShiftRightLogical(Reg8),
    ShiftRightArith(Reg8),
    SwapBytes(Reg8)
}

impl fmt::Display for Instr {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            Instr::Bad(opcode) => write!(f, "<{:02x}>", opcode),
            Instr::Nop => write!(f, "NOP"),
            Instr::Stop => write!(f, "STOP"),
            Instr::StoreSP(addr) => write!(f, "LD ({:#04x}),SP", addr),
            Instr::JumpRelative(offset, Cond::Always) => write!(f, "JR {}", offset),
            Instr::JumpRelative(offset, cond) => write!(f, "JR{},{}", cond, offset),
            Instr::LoadImm16(reg, imm) => write!(f, "LD {},{:#04x}", reg, imm),
            Instr::AddHL(reg) => write!(f, "ADD HL,{}", reg),
            Instr::StoreA(indirect) => write!(f, "LD {},A", indirect),
            Instr::LoadA(indirect) => write!(f, "LD A,{}", indirect),
            Instr::Inc8(reg) => write!(f, "INC {}", reg),
            Instr::Dec8(reg) => write!(f, "DEC {}", reg),
            Instr::Inc16(reg) => write!(f, "INC {}", reg),
            Instr::Dec16(reg) => write!(f, "DEC {}", reg),
            Instr::LoadImm8(reg,imm) => write!(f, "LD {},{:#02x}", reg, imm),
            Instr::RotateALeft => write!(f, "RLCA"),
            Instr::RotateALeftCarry => write!(f, "RLA"),
            Instr::RotateARight => write!(f, "RRCA"),
            Instr::RotateARightCarry => write!(f, "RRA"),
            Instr::DecimalAdjust => write!(f, "DAA"),
            Instr::Complement => write!(f, "CPL"),
            Instr::ComplementCarry => write!(f, "CCF"),
            Instr::SetCarry => write!(f, "SCF"),
            Instr::Halt => write!(f, "HALT"),
            Instr::RegCopy(to, from) => write!(f, "LD {},{}", to, from),
            Instr::Add(reg) => write!(f, "ADD A,{}", reg),
            Instr::AddCarry(reg) => write!(f, "ADC A,{}", reg),
            Instr::Sub(reg) => write!(f, "SUB {}", reg),
            Instr::SubCarry(reg) => write!(f, "SBC A,{}", reg),
            Instr::And(reg) => write!(f, "AND {}", reg),
            Instr::Xor(reg) => write!(f, "XOR {}", reg),
            Instr::Or(reg) => write!(f, "OR {}", reg),
            Instr::Comp(reg) => write!(f, "CP {}", reg),
            Instr::AddImm(imm) => write!(f, "ADD A,{:#02x}", imm),
            Instr::AddCarryImm(imm) => write!(f, "ADC A,{:#02x}", imm),
            Instr::SubImm(imm) => write!(f, "SUB {:#02x}", imm),
            Instr::SubCarryImm(imm) => write!(f, "SBC A,{:#02x}", imm),
            Instr::AndImm(imm) => write!(f, "AND {:#02x}", imm),
            Instr::XorImm(imm) => write!(f, "XOR {:#02x}", imm),
            Instr::OrImm(imm) => write!(f, "OR {:#02x}", imm),
            Instr::CompImm(imm) => write!(f, "CP {:#02x}", imm),
            Instr::Ret(cond) => write!(f, "RET{}", cond),
            Instr::RetI => write!(f, "RETI"),
            Instr::StoreIO(imm) => write!(f, "LD (0xff00+{:#02x}),A", imm),
            Instr::LoadIO(imm) => write!(f, "LD A,(0xff00+{:#02x})", imm),
            Instr::StackAdjust(imm) => write!(f, "ADD SP,{:#02x}", imm), // TODO:
            Instr::LoadLocalAddr(imm) => write!(f, "LD HL,SP{:+#02x}", imm),
            Instr::Pop(reg) => write!(f, "POP {}", reg),
            Instr::Push(reg) => write!(f, "PUSH {}", reg),
            Instr::Jump(addr, Cond::Always) => write!(f, "JP {:x}", addr),
            Instr::Jump(addr, cond) => write!(f, "JP{},{:x}", cond, addr),
            Instr::JumpHL => write!(f, "JP (HL)"),
            Instr::LoadStackHL => write!(f, "LD SP, HL"),
            Instr::LoadIOC => write!(f, "LD A,(0xffoo+C)"),
            Instr::StoreIOC => write!(f, "LD (0xffoo+C),A"),
            Instr::LoadGlobal(imm) => write!(f, "LD A,({:#04x})",imm),
            Instr::StoreGlobal(imm) => write!(f, "LD ({:#04x}),A",imm),
            Instr::DisableInterrupts => write!(f, "DI"),
            Instr::EnableInterrupts => write!(f, "EI"),
            Instr::Call(addr, cond) => write!(f, "CALL{} {:#04x}", cond, addr),
            Instr::Restart(index) => write!(f, "RST {:#02x}", index * 8),
            Instr::Bit(reg, bit) => write!(f, "BIT {},{}", bit, reg),
            Instr::Reset(reg, bit) => write!(f, "RES {},{}", bit, reg),
            Instr::Set(reg, bit) => write!(f, "SET {},{}", bit, reg),
            Instr::RotateLeft(reg) => write!(f, "RLC {}", reg),
            Instr::RotateLeftCarry(reg) => write!(f, "RL {}", reg),
            Instr::RotateRight(reg) => write!(f, "RRC {}", reg),
            Instr::RotateRightCarry(reg) => write!(f, "RR {}", reg),
            Instr::ShiftLeft(reg) => write!(f, "SLA {}", reg),
            Instr::ShiftRightLogical(reg) => write!(f, "SRL {}", reg),
            Instr::ShiftRightArith(reg) => write!(f, "SRA {}", reg),
            Instr::SwapBytes(reg) => write!(f, "SWAP {}", reg),
        }
    }
}
